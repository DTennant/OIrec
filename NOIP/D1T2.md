25分

　　考虑此时nn很小，可以对于每条路径上暴力模拟，经过某个点时可以看一下当前时刻，是否跟经过的点的ww相等，如果相等，则贡献加一。

 

45分

　　注意到测试点9−129−12时，保证mm条路径的出发点都是11，那么我们可以考虑如果将11作为树根，那么一条路径怎样才能对于它经过的点产生贡献。

　　不难看出对于一个点ii，只有在deep[i]=w[i]deep[i]=w[i]，才有可能有贡献。

　　我在考场上是直接用的链剖++线段树，因为这就变成模板题了，而且nn不到10w10w，尽管复杂度偏高，但是不易错。

　　直接对于每条路径经过的点在线段树上增加11次经过次数，显然只有deepdeep与ww相等的点才会产生贡献。

　　事实上对于S=1S=1的情况有线性的算法，正解会详细介绍，不再赘述。

 

60分

　　注意到测试点6−86−8时，题目保证树退化成链。我们观察一下对于链而言，有什么特别的地方。首先要明确，此时m条路径在链上肯定是要么往左要么往右，即S<=TS<=T或者S>TS>T。

　　先只考虑S<=TS<=T的情况，如果对于SS到TT之间的点i，要产生贡献的话，肯定满足i−S=w[i]i−S=w[i]，移项可得S=i−w[i]S=i−w[i]时才可以满足要求。

　　注意到等式右边只与ii本身有关，不妨设为K[i]K[i]，所以题目变成了查询SS到TT之间K[i]K[i]等于SS的ii的数量。

　　因为题目只涉及到首和尾，我们可以很容易联想到差分，即对于SS打上+1+1标记，TT打上−1−1标记。

　　根据上述思路，我们考虑具体做法：对于每个点ii,我们很容易发现只有从一个特定的点出发才有可能对ii产生贡献。

　　我们考虑维护一个统计数组AA，A[k]A[k]表示的是处理到当前的结点时，从kk出发的路径（而且还没有走到终点）有多少条。

　　这样对于每个点ii，我们只要查询一下所对应的A[K[i]]A[K[i]]就可以了，根据上面的分析，这就是我们的答案了。

　　有一点注意处理：处理一个点ii时，我们需要把以ii为起点的路径加入统计数组AA，再计算这个结点的贡献，最后再把以这个结点为终点的路径从AA中消除，具体可以用vectorvector实现（上述处理顺序的必要性仔细想想就很容易想通了）。

　　而对于S>TS>T的情况完全类似，只是需要把K[i]K[i]定义为i+w[i]i+w[i]，其余做法完全类似。

      

100分

　　题目中设计的几个档次的部分分其实暗示已经很明显了。

　　链的做法离正解就不远了。

　　而S=1S=1和T=1T=1是在告诉我们什么呢？

　　拆路径！

　　很容易发现，一条SS到TT的路径可以拆成一条SS到LCALCA的路径和LCALCA到TT的路径，然后对于这两条路径，一条往上，一条往下，都可以对应成链的处理方式了！

　　考虑对于每条路径，先将其拆分成两条路径（为了简化对LCALCA在两条路径中都出现的各种情况，我们可以先就让LCALCA出现两次，如果最后发现LCALCA是有贡献的，只需−1−1即可），同样，我们先只考虑向上的路径。

　　如果我们对于SS在统计数组AA上打上11的标记，LCALCA在统计数组AA上打上−1−1的标记，那么题目转化为求一个点的子树和。

　　考虑上述做法正确性：因为只有SS到LCALCA路径之间的点会产生贡献，而当这个点位于路径之间时，子树和会产生11的贡献，而在SS的子树中或者LCALCA的上方都不会产生贡献。

　　具体实现呢？

　　对于一个点ii，产生贡献的条件是deep[S]−deep[i]=w[i]deep[S]−deep[i]=w[i]，同样令K[i]=deep[i]+w[i]K[i]=deep[i]+w[i]，当我们dfsdfs到ii时查询A[k[i]]A[k[i]]的值即为贡献。

　　为了保证正确性，我们思考统计答案的方式和顺序。

　　首先我们肯定是在处理完ii的子树之后再来处理ii（想想就知道了），然后我们需要再把以ii出发的向上的路径加入统计数组，再进行查询，最后把以ii为终点的路径所产生的贡献在统计数组AA中消除即可。

　　注意到我们上面维护的仅仅是一个点的深度，由于同一深度的点很多，所以我们查询的时候会发现会把不在同一子树的点统计入答案，那怎么办呢？我们考虑对于一个点要查询子树和，肯定是只要单独地考虑这一个子树的贡献，所以我们可以记录进入ii时A[k[i]]A[k[i]]的值，再在访问完ii的子树之后统计答案时，看一下此时新的A[k[i]]A[k[i]]的值。

　　容易发现新的值减掉进入时的，才是真正的ii的子树中的A[k[i]]A[k[i]]的值。

　　这样我们就可以避免把别的子树的答案统计进来了。

　　对于向下的点做法类似，有一点复杂的地方就是等式变成了deep[T]−deep[i]=len−w[i]deep[T]−deep[i]=len−w[i]（lenlen为路径长度），发现如果这样做的话会出现负数，那么我们就把统计数组向右平移3∗1053∗105位就可以了。

　　上述做法如果采用的是倍增求LCALCA的话，复杂度就是O(nlogn)O(nlogn)；

　　如果用tarjantarjan离线求LCALCA的话，可以做到O(n+m)O(n+m)。

 

 

 注意事项

　　对于树上每个结点，统计答案时不能直接查询在统计数组中的对应的路径条数，

　　而应该统计dfsdfs进入ii时，和访问完ii的子树时的变化量。