25分

　　考虑此时n很小，可以对于每条路径上暴力模拟，经过某个点时可以看一下当前时刻，是否跟经过的点的w相等，如果相等，则贡献加一。

 

45分

　　注意到测试点9−12时，保证m条路径的出发点都是1，那么我们可以考虑如果将1作为树根，那么一条路径怎样才能对于它经过的点产生贡献。

　　不难看出对于一个点i，只有在deep[i]=w[i]，才有可能有贡献。

　　直接对于每条路径经过的点在线段树上增加1次经过次数，显然只有deep与w相等的点才会产生贡献。

　　事实上对于S=1的情况有线性的算法，正解会详细介绍，不再赘述。

 

60分

　　注意到测试点6−8时，题目保证树退化成链。我们观察一下对于链而言，有什么特别的地方。首先要明确，此时m条路径在链上肯定是要么往左要么往右，即S<=T或者S>T。

　　先只考虑S<=T的情况，如果对于S到T之间的点i，要产生贡献的话，肯定满足i−S=w[i]，移项可得S=i−w[i]时才可以满足要求。

　　注意到等式右边只与i本身有关，不妨设为K[i]，所以题目变成了查询S到T之间K[i]等于S的i的数量。

　　因为题目只涉及到首和尾，我们可以很容易联想到差分，即对于S打上+1标记，T打上−1标记。

　　根据上述思路，我们考虑具体做法：对于每个点i,我们很容易发现只有从一个特定的点出发才有可能对i产生贡献。

　　我们考虑维护一个统计数组A，A[k]表示的是处理到当前的结点时，从k出发的路径（而且还没有走到终点）有多少条。

　　这样对于每个点i，我们只要查询一下所对应的A[K[i]]就可以了，根据上面的分析，这就是我们的答案了。

　　有一点注意处理：处理一个点i时，我们需要把以ii为起点的路径加入统计数组A，再计算这个结点的贡献，最后再把以这个结点为终点的路径从A中消除，具体可以用vector实现（上述处理顺序的必要性仔细想想就很容易想通了）。

　　而对于S>T的情况完全类似，只是需要把K[i]定义为i+w[i]，其余做法完全类似。

      

100分

　　题目中设计的几个档次的部分分其实暗示已经很明显了。

　　链的做法离正解就不远了。

　　而S=1和T=1是在告诉我们什么呢？

　　拆路径！

　　很容易发现，一条S到T的路径可以拆成一条S到LCA的路径和LCA到T的路径，然后对于这两条路径，一条往上，一条往下，都可以对应成链的处理方式了！

　　考虑对于每条路径，先将其拆分成两条路径（为了简化对LCA在两条路径中都出现的各种情况，我们可以先就让LCA出现两次，如果最后发现LCA是有贡献的，只需−1即可），同样，我们先只考虑向上的路径。

　　如果我们对于S在统计数组A上打上1的标记，LCA在统计数组A上打上−1的标记，那么题目转化为求一个点的子树和。

　　考虑上述做法正确性：因为只有S到LCA路径之间的点会产生贡献，而当这个点位于路径之间时，子树和会产生1的贡献，而在S的子树中或者LCA的上方都不会产生贡献。

　　具体实现呢？

　　对于一个点ii，产生贡献的条件是deep[S]−deep[i]=w[i]，同样令K[i]=deep[i]+w[i]，当我们dfs到i时查询A[k[i]]的值即为贡献。

　　为了保证正确性，我们思考统计答案的方式和顺序。

　　首先我们肯定是在处理完i的子树之后再来处理i（想想就知道了），然后我们需要再把以i出发的向上的路径加入统计数组，再进行查询，最后把以i为终点的路径所产生的贡献在统计数组A中消除即可。

　　注意到我们上面维护的仅仅是一个点的深度，由于同一深度的点很多，所以我们查询的时候会发现会把不在同一子树的点统计入答案，那怎么办呢？我们考虑对于一个点要查询子树和，肯定是只要单独地考虑这一个子树的贡献，所以我们可以记录进入ii时A[k[i]]的值，再在访问完i的子树之后统计答案时，看一下此时新的A[k[i]]的值。

　　容易发现新的值减掉进入时的，才是真正的i的子树中的A[k[i]]的值。

　　这样我们就可以避免把别的子树的答案统计进来了。

　　对于向下的点做法类似，有一点复杂的地方就是等式变成了deep[T]−deep[i]=len−w[i]（len为路径长度），发现如果这样做的话会出现负数，那么我们就把统计数组向右平移300000位就可以了。

　　上述做法如果采用的是倍增求LCA的话，复杂度就是O(nlogn)；

　　如果用tarjan离线求LCA的话，可以做到O(n+m)。

 

 

 注意事项

　　对于树上每个结点，统计答案时不能直接查询在统计数组中的对应的路径条数，

　　而应该统计dfs进入i时，和访问完i的子树时的变化量。